36. What's In An Image (and What Isn't)
Image
- app binaries and dependencies
- metadata about the image data and how to run the image
- official: "An image is an ordered collection of root filesystem changes and the corresponding execution parameters for use within a container runtime"
- not a complete OS -- no kernel, no kernel modules (e.g. drivers)
- as small as one file, or as big as an Ubuntu distro with apt, Apache, PHP and more installed


37. The Mighty Hub: Using Docker Hub Registry Images
Docker Hub: https://hub.docker.com/
- rare to want your software to update automatically; instead, you usually want to control that process with some other DevOps tool
- vet an image by:
-- looking at number of pulls and number of stars
-- looking at an open source repository that shows how the image was made
[[Resources]]
List of Official Docker Images:
https://github.com/docker-library/official-images/tree/master/library


38. Images and Their Layers: Discover the Image Cache
[docker image ls]
[docker history nginx:latest]
- every image starts with a blank layer known as [scratch]
- every set of changes on the file system in the image is another [layer]
- every layer gets its own unique [sha] to allow system to confirm that layer is different from another layer, storing each layer only once on a host
[Copy-on-Write] when container changes a layer on the image; copies file out into container's differencing for storage in container layer
[docker image inspect nginx] gives you [metadata] for an image

[[Resources]]
*About storage drivers*
https://docs.docker.com/storage/storagedriver/
- "Containers that write a lot of data consume more space than containers that do not. This is because most write operations consume new space in the container’s thin writable top layer.

Note: for write-heavy applications, you should not store the data in the container. Instead, use Docker volumes, which are independent of the running container and are designed to be efficient for I/O. In addition, volumes can be shared among containers and do not increase the size of your container’s writable layer."


39. Image Tagging and Pushing to Docker Hub
## Tagging
- Tag vs "Repository" as username or organization slash repository
- only official images get to be called just the repository name -- i.e. no username or organization designation
- tags are a little bit like [Git tags] an a little like [versions]
- a pointer to a specific image commit or really anything in that repository
- descriptions of images usually show [MULTIPLE Tags] (shown as both numbers and names) in each bullet for the [SAME Image ID]
- can [re-tag] existing Docker images
[docker image tag OriginalName[:TAG] NewName[:TAG]]
[docker image tag nginx bretfisher/nginx]
[docker image push bretfish/nginx] pushes/uploads changed layers to an image registry (default: Docker Hub)
- likely will be denied because [docker login] first required
- [docker login] without URL defaults to logging in to Docker Hub; can override by adding a server URL
-- used to store in config.json [cat .docker/config.json] file but now Docker for Mac stores the auth in Keychain for that user for better security
-- can [docker logout] if done or can't trust machine
- can push to a private repository, but best to make it private as of first creation


40. Building Images: The Dockerfile Basics
[Dockerfile] - recipe for creating your image
[cd dockerfile-sample-1/]
[code Dockerfile]
[docker build -f some-dockerfile] uses -f to specify a different file from the default [Dockerfile]

[FROM] required, usually a minimal distribution, then use their package distribution systems to install what you need in your package

[ENV] stanza for environement variables settings, as the main way to set keys and values for container building and running containers
- each [stanza] is a [layer] in our docker [image], so order matters (top down)

[RUN] commands execute shell commands inside the container as it's building it (e.g. installing software with a package distribution system, or unzipping, or file editing inside container, or running shell scripts copied in earlier in the file, or any commands you can access inside the container at that point in time in the file
- proper way to do [logging] inside a container is to NOT log to a log file
- there's no [syslogd] or any other [syslog service] inside a container
- Docker handles all logging for us
- all we have to do is make sure everything we want captured is spit out to stdout and stderr
[RUN ln -sf /dev/stdout /var/log/nginx/access.log \
&& ln -sf /dev/stderr /var/log/nginx/error.log]

[EXPOSE] since by default NO TCP nor UDP ports are open inside a container
- does not expose anything from the container to a virtual network unless we list it in EXPOSE
- expose both ports 80 and 443 by [EXPOSE 80 443]
- does NOT mean these ports are opened automatically on our host; [-p] or [--publish] is used for that

[CMD] required parameter that is the final command that will be run every time you launch a new container from the image or every time you restart a stopped container


[[Resources]]
https://docs.docker.com/engine/reference/builder/


41. Building Images: Running Docker Builds
42. Building Images: Extending Official Images
Quiz 4: Image Quiz
43. Assignment: Build Your Own Dockerfile and Run Containers From It
44. Assignment Answers: Build Your Own Dockerfile and Run Containers From It
45. Using Prune to Keep Your Docker System Clean (YouTube)
